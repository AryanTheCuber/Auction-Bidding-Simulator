<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üî•Auction Bidding Simulatorüî•</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    
    <style>
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Montserrat', sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 20px; transition: background 0.3s ease; }
        
        /* Dark Mode */
        body.dark-mode { background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); }
        body.dark-mode .container { background: #0f3460; color: #e8e8e8; }
        body.dark-mode .panel { background: #16213e; }
        body.dark-mode .panel h2 { color: #e8e8e8; }
        body.dark-mode .player-item, body.dark-mode .fairness-log, body.dark-mode .strategy-panel, body.dark-mode .suggestions-panel, body.dark-mode .leaderboard, body.dark-mode .log-area { background: #1a1a2e; color: #e8e8e8; }
        body.dark-mode .player-name { color: #e8e8e8; }
        body.dark-mode .leaderboard th { background: #533483; }
        body.dark-mode .leaderboard td { border-bottom-color: #333; }
        body.dark-mode .strategy-item, body.dark-mode .suggestion-item { background: #1a1a2e; border-left-color: #667eea; }
        body.dark-mode .strategy-item .player-strategy, body.dark-mode .strategy-item .strategy-type, body.dark-mode .suggestion-item .player-name-sug { color: #e8e8e8; }
        body.dark-mode .strategy-item .strategy-desc, body.dark-mode .suggestion-item .suggestion-text { color: #b8b8b8; }
        body.dark-mode .log-round { color: #a8b5ff; }
        body.dark-mode .log-bid { color: #e8e8e8; }
        body.dark-mode .log-result { color: #4ade80; }
        body.dark-mode .auction-info { background: linear-gradient(135deg, #533483 0%, #3d2659 100%); }
        body.dark-mode .item-name, body.dark-mode .timer, body.dark-mode .detail-item, body.dark-mode .highest-bid { color: #ffffff; }
        body.dark-mode .player-purse { color: #4ade80; }
        body.dark-mode input::placeholder { color: #888; }
        body.dark-mode .status-bar { background: #16213e; border-top-color: #333; color: #e8e8e8; }
        body.dark-mode .setup-controls input { background: rgba(255,255,255,0.1); color: #e8e8e8; border-color: rgba(255,255,255,0.2); }
        body.dark-mode .player-controls input { background: #1a1a2e; color: #e8e8e8; border-color: #333; }
        
        /* Container & Layout */
        .container { max-width: 1400px; margin: 0 auto; background: white; border-radius: 12px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); overflow: hidden; }
        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px 30px; }
        .header h1 { font-size: 28px; margin-bottom: 15px; }
        
        /* Controls */
        .setup-controls { display: flex; gap: 15px; flex-wrap: wrap; align-items: center; }
        .setup-controls label { font-size: 14px; }
        .setup-controls input { padding: 8px 12px; border: 1px solid rgba(255,255,255,0.3); border-radius: 6px; background: rgba(255,255,255,0.9); font-size: 14px; }
        .setup-controls button { padding: 10px 20px; border: none; border-radius: 6px; font-weight: bold; cursor: pointer; transition: all 0.3s; font-size: 14px; }
        .btn-start { background: #28a745; color: white; }
        .btn-ai { background: #6f42c1; color: white; }
        .btn-start:hover { background: #218838; transform: translateY(-2px); }
        .btn-ai:hover { background: #5a32a3; transform: translateY(-2px); }
        
        /* Main Grid */
        .main-layout { display: grid; grid-template-columns: 1fr 2fr 1fr; gap: 20px; padding: 20px; min-height: 600px; }
        .panel { background: #f8f9fa; border-radius: 8px; padding: 15px; overflow-y: auto; max-height: 700px; }
        .panel h2 { font-size: 18px; margin-bottom: 15px; color: #333; border-bottom: 2px solid #667eea; padding-bottom: 8px; }
        
        /* Player Items */
        .player-item { background: white; padding: 12px; margin-bottom: 10px; border-radius: 6px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .player-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .player-name { font-weight: bold; color: #333; }
        .player-purse { color: #28a745; font-weight: bold; }
        
        /* Player Controls (Buttons) */
        .player-controls { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
        .player-controls input { width: 100px; padding: 6px; border: 1px solid #ddd; border-radius: 4px; }
        .quick-bid-buttons { display: flex; gap: 4px; margin-top: 6px; flex-wrap: wrap; }
        .quick-bid-buttons button { padding: 4px 8px; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 10px; transition: all 0.2s; font-family: 'Montserrat', sans-serif; }
        
        .btn-quick-min { background: #17a2b8; color: white; }
        .btn-quick-10 { background: #ffc107; color: #333; }
        .btn-quick-25 { background: #fd7e14; color: white; }
        .btn-quick-max { background: #dc3545; color: white; }
        .btn-withdraw { background: #6c757d; color: white; font-size: 10px; padding: 4px 8px; }
        .player-withdrawn { opacity: 0.5; }
        .player-controls button { padding: 6px 12px; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; transition: all 0.2s; }
        .btn-bid { background: #ff9800; color: white; }
        .btn-bid:hover { background: #e68900; }
        .btn-ai-toggle { background: #6f42c1; color: white; font-size: 12px; }
        .btn-ai-toggle:hover { background: #5a32a3; }
        
        /* Auction Info Center */
        .center-panel { display: flex; flex-direction: column; }
        .auction-info { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 8px; margin-bottom: 15px; }
        .auction-header { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px; }
        .item-name { font-size: 20px; font-weight: bold; }
        .timer { font-size: 24px; font-weight: bold; color: #ffd700; }
        .auction-details { display: flex; gap: 20px; margin-top: 10px; flex-wrap: wrap; }
        .detail-item { font-size: 14px; }
        .highest-bid { font-size: 18px; font-weight: bold; color: #4ade80; margin-top: 10px; }
        
        /* Logs */
        .log-area { flex: 1; background: white; border-radius: 8px; padding: 15px; overflow-y: auto; font-family: 'Courier New', monospace; font-size: 13px; line-height: 1.6; max-height: 400px; }
        .log-entry { margin-bottom: 5px; }
        .log-round { color: #667eea; font-weight: bold; }
        .log-bid { color: #333; }
        .log-result { color: #28a745; font-weight: bold; }
        
        /* Host Controls */
        .control-buttons { display: flex; gap: 10px; margin-top: 15px; }
        .control-buttons button { flex: 1; padding: 12px; border: none; border-radius: 6px; font-weight: bold; cursor: pointer; transition: all 0.3s; }
        .btn-end { background: #dc3545; color: white; }
        .btn-next { background: #007bff; color: white; }
        .btn-results { background: #6c757d; color: white; }
        
        /* Right Panel Widgets */
        .fairness-log { background: white; padding: 10px; border-radius: 6px; max-height: 150px; overflow-y: auto; margin-bottom: 15px; font-size: 12px; line-height: 1.5; }
        .strategy-panel { background: white; padding: 10px; border-radius: 6px; max-height: 200px; overflow-y: auto; margin-bottom: 15px; font-size: 12px; }
        .strategy-item { padding: 8px; margin-bottom: 8px; border-left: 3px solid #667eea; background: #f8f9fa; border-radius: 4px; }
        .strategy-item .player-strategy { font-weight: bold; color: #333; margin-bottom: 4px; }
        .strategy-item .strategy-type { color: #667eea; font-weight: bold; }
        .strategy-item .strategy-desc { color: #666; font-size: 11px; margin-top: 3px; }
        .suggestions-panel { background: white; padding: 10px; border-radius: 6px; max-height: 200px; overflow-y: auto; margin-bottom: 15px; font-size: 12px; }
        .suggestion-item { padding: 8px; margin-bottom: 8px; border-left: 3px solid #28a745; background: #f0f8f4; border-radius: 4px; }
        .suggestion-item .player-name-sug { font-weight: bold; color: #333; margin-bottom: 4px; }
        .suggestion-item .suggestion-text { color: #555; font-size: 11px; line-height: 1.4; }
        
        /* Leaderboard */
        .leaderboard { background: white; border-radius: 6px; overflow: hidden; }
        .leaderboard table { width: 100%; border-collapse: collapse; }
        .leaderboard th { background: #667eea; color: white; padding: 10px 8px; text-align: left; font-size: 12px; }
        .leaderboard td { padding: 8px; border-bottom: 1px solid #eee; font-size: 12px; }
        .leaderboard tr:hover { background: #f8f9fa; }
        
        /* Modals */
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000; align-items: center; justify-content: center; }
        .modal.active { display: flex; }
        .modal-content { background: white; padding: 30px; border-radius: 12px; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto; }
        .modal-content h2 { margin-bottom: 20px; color: #333; }
        .modal-content label { display: block; margin: 15px 0 5px; font-weight: bold; }
        .modal-content input, .modal-content select { width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px; }
        .modal-buttons { display: flex; gap: 10px; margin-top: 20px; }
        .modal-buttons button { flex: 1; padding: 12px; border: none; border-radius: 6px; font-weight: bold; cursor: pointer; }
        
        /* Status Bar */
        .status-bar { background: #f8f9fa; padding: 10px 20px; border-top: 1px solid #ddd; font-size: 14px; color: #666; display: flex; justify-content: space-between; align-items: center; }
        .dark-mode-toggle { background: #333; color: white; border: none; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 12px; transition: all 0.3s; }
        .dark-mode-toggle:hover { background: #555; }
        
        /* Multiplayer Section */
        .multiplayer-section { background: rgba(255, 255, 255, 0.1); padding: 15px; border-radius: 8px; margin-top: 15px; }
        .multiplayer-section h3 { font-size: 16px; margin-bottom: 10px; }
        .multiplayer-controls { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
        .multiplayer-controls input { padding: 8px 12px; border: 1px solid rgba(255,255,255,0.3); border-radius: 6px; background: rgba(255,255,255,0.9); font-size: 14px; width: 200px; }
        .multiplayer-controls button { padding: 10px 20px; border: none; border-radius: 6px; font-weight: bold; cursor: pointer; transition: all 0.3s; font-size: 14px; }
        .btn-create-room { background: #17a2b8; color: white; }
        .btn-join-room { background: #ffc107; color: #333; }
        .btn-leave-room { background: #dc3545; color: white; }
        .room-info { background: rgba(255,255,255,0.2); padding: 10px 15px; border-radius: 6px; margin-top: 10px; display: flex; justify-content: space-between; align-items: center; }
        .room-code { font-size: 20px; font-weight: bold; letter-spacing: 2px; color: #ffd700; }
        .online-players { background: rgba(76, 175, 80, 0.3); padding: 4px 12px; border-radius: 12px; font-size: 12px; }
        .firebase-config-notice { background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 15px; margin: 15px 0; color: #856404; }
        .firebase-config-notice h4 { margin-bottom: 10px; color: #856404; }
        .firebase-config-notice code { background: #fff; padding: 2px 6px; border-radius: 4px; font-family: 'Courier New', monospace; }
        .ai-badge { background: #6f42c1; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; margin-left: 8px; }
        @media (max-width: 1200px) { .main-layout { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üî•Auction Bidding Simulatorüî•</h1>
            <div class="setup-controls">
                <label>
                    Players (Name or Name:Amount):
                    <input type="text" id="playersInput" placeholder="Player1:10000, Player2:15000..." style="width: 400px;">
                </label>
                <label>
                    Rounds:
                    <input type="number" id="roundsInput" value="5" min="1" max="10" style="width: 70px;">
                </label>
                <button class="btn-start" onclick="startTournament()">Start Tournament</button>
                <button class="btn-ai" onclick="showAddAIModal()">Add AI Bot</button>
            </div>
            
            <div id="multiplayerStatus">
                <div class="multiplayer-controls">
                    <input type="text" id="roomCodeInput" placeholder="Enter room code to join...">
                    <button class="btn-create-room" onclick="createRoom()">Create Room</button>
                    <button class="btn-join-room" onclick="joinRoom()">Join Room</button>
                </div>
            </div>
        </div>

        <div class="main-layout">
            <div class="panel">
                <h2>üë• Players</h2>
                <div id="playersPanel"></div>
            </div>

            <div class="center-panel">
                <div class="auction-info">
                    <div class="auction-header">
                        <div>
                            <div class="item-name" id="itemName">-</div>
                            <div class="auction-details">
                                <div class="detail-item">Base: <span id="basePrice">-</span></div>
                                <div class="detail-item">Min Inc: <span id="minIncrement">-</span></div>
                            </div>
                        </div>
                        <div class="timer" id="timer">‚è≥ 00:00</div>
                    </div>
                    <div class="highest-bid" id="highestBid">Highest: ‚Çπ0 -</div>
                </div>

                <div class="panel" style="flex: 1;">
                    <h2>üìã Auction Log</h2>
                    <div class="log-area" id="auctionLog"></div>
                    <div class="control-buttons">
                        <button class="btn-end" onclick="endRound()" id="btnEndRound">End Round Now</button>
                        <button class="btn-next" onclick="nextRound()" id="btnNextRound">Next Round</button>
                        <button class="btn-results" onclick="showFinalResults()">Final Results</button>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h2>‚öñÔ∏è Fairness & Alerts</h2>
                <div class="fairness-log" id="fairnessLog"></div>
                
                <h2>üí° Strategy Insights</h2>
                <div class="strategy-panel" id="strategyPanel"></div>
                
                <h2>üéØ Suggestions (Losers)</h2>
                <div class="suggestions-panel" id="suggestionsPanel"></div>
                
                <h2>üèÖ Leaderboard</h2>
                <div class="leaderboard">
                    <table id="leaderboardTable">
                        <thead>
                            <tr>
                                <th>Player</th>
                                <th>Wins</th>
                                <th>Spent</th>
                                <th>Bids</th>
                                <th>Purse</th>
                            </tr>
                        </thead>
                        <tbody id="leaderboardBody"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <div class="status-bar">
            <span id="statusBar">Ready</span>
            <button class="dark-mode-toggle" onclick="toggleDarkMode()">üåô Dark Mode</button>
        </div>
    </div>

    <!-- Modals -->
    <div class="modal" id="aiModal">
        <div class="modal-content">
            <h2 id="aiModalTitle">Configure AI</h2>
            <label>Strategy:</label>
            <select id="aiStrategy">
                <option>Incremental</option>
                <option>Aggressive</option>
                <option>Conservative</option>
                <option>Passive</option>
                <option>Adaptive</option>
                <option>Sniper</option>
                <option>Rapid</option>
            </select>
            <label style="margin-top: 15px;">
                <input type="checkbox" id="aiActive"> Activate AI
            </label>
            <div class="modal-buttons">
                <button class="btn-start" onclick="applyAIConfig()">Apply</button>
                <button class="btn-end" onclick="closeAIModal()">Cancel</button>
            </div>
        </div>
    </div>

    <div class="modal" id="addAIModal">
        <div class="modal-content">
            <h2>Create New AI Bot</h2>
            <label>AI Name:</label>
            <input type="text" id="newAIName" placeholder="AI_Bot1">
            <label>Purse (‚Çπ):</label>
            <input type="number" id="newAIPurse" value="10000">
            <label>Strategy:</label>
            <select id="newAIStrategy">
                <option>Incremental</option>
                <option>Aggressive</option>
                <option>Conservative</option>
                <option>Passive</option>
                <option>Adaptive</option>
                <option>Sniper</option>
                <option>Rapid</option>
            </select>
            <label style="margin-top: 15px;">
                <input type="checkbox" id="newAIActive" checked> Activate AI immediately
            </label>
            <div class="modal-buttons">
                <button class="btn-start" onclick="createAIBot()">Create AI Bot</button>
                <button class="btn-end" onclick="closeAddAIModal()">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // FIREBASE CONFIGURATION
        // ============================================
        const firebaseConfig = {
            apiKey: "AIzaSyDfrW6SMExgRnHjSM5bfCyQ4tRuBKIydqQ",
            authDomain: "auction-bidding-simulator.firebaseapp.com",
            databaseURL: "https://auction-bidding-simulator-default-rtdb.firebaseio.com",
            projectId: "auction-bidding-simulator",
            storageBucket: "auction-bidding-simulator.firebasestorage.app",
            messagingSenderId: "97454594868",
            appId: "1:97454594868:web:7a50a5f1c8c39fceba2361"
        };

        let firebaseInitialized = false;
        let database = null;

        try {
            firebase.initializeApp(firebaseConfig);
            database = firebase.database();
            firebaseInitialized = true;
            console.log("‚úÖ Firebase initialized successfully!");
        } catch (error) {
            console.error("‚ùå Firebase initialization error:", error);
            showFirebaseSetupNotice();
        }

        function showFirebaseSetupNotice() {
            const notice = document.createElement('div');
            notice.className = 'firebase-config-notice';
            notice.innerHTML = `
                <h4>üîß Firebase Setup Required for Multiplayer</h4>
                <p><strong>To enable multiplayer mode:</strong></p>
                <ol style="margin: 10px 0; padding-left: 20px;">
                    <li>Go to <a href="https://console.firebase.google.com" target="_blank">console.firebase.google.com</a></li>
                    <li>Click Realtime Database > Rules</li>
                    <li>Change read/write to true</li>
                </ol>
            `;
            document.querySelector('.main-layout').prepend(notice);
            document.querySelectorAll('.multiplayer-controls button').forEach(btn => {
                btn.disabled = true;
                btn.style.opacity = '0.5';
                btn.style.cursor = 'not-allowed';
            });
        }

        // ============================================
        // GAME STATE & CONSTANTS
        // ============================================
        let multiplayerMode = false;
        let currentRoom = null;
        let currentPlayerName = null;
        let isHost = false;
        let roomRef = null;

        const MAX_PLAYERS = 10;
        const MAX_ROUNDS = 10;
        const ROUND_DURATION = 60;
        const ANTI_SNIPING_WINDOW = 5;
        const ANTI_SNIPING_EXTENSION = 10;
        const ANTI_SPAM_SECONDS = 2;
        const UNUSUAL_MULTIPLIER = 3;
        const MIN_INCREMENT_RATIO = 0.20;

        const ITEMS = [
            ["Charizard Pokemon Card", 10000],
            ["Signed Virat Kohli Jersey", 80000],
            ["1600 BCE Gold Sword", 20000],
            ["Antique Painting", 60000],
            ["Drone", 20000],
            ["Smart TV", 30000],
            ["Diamond Ring", 75000],
            ["Camera", 25000],
            ["Robot Kit", 15000],
            ["Electric Guitar", 18000]
        ];

        let state = {
            players: [],
            purses: {},
            startingPurses: {},
            numRounds: 0,
            currentRound: 0,
            currentItem: null,
            highestBid: 0,
            highestBidder: null,
            lastBidder: null,
            bidHistory: [],
            perRoundPlayerBids: {},
            perPlayerLastBidTime: {},
            suspiciousBids: [],
            roundResults: [],
            timerRunning: false,
            roundTimeLeft: 0,
            roundEndTime: 0,
            timerInterval: null,
            aiPlayers: {},
            aiTimers: {},
            minIncrement: 0,
            currentAIPlayer: null,
            withdrawnPlayers: {},
            roundStatus: 'waiting' // 'waiting', 'active', 'ended'
        };

        document.getElementById('playersInput').value = Array.from({length: 3}, (_, i) => `Player${i+1}:10000`).join(', ');

        // ============================================
        // MULTIPLAYER FUNCTIONS
        // ============================================

        function generateRoomCode() {
            return 'ROOM-' + Math.random().toString(36).substr(2, 6).toUpperCase();
        }

        function createRoom() {
            if (!firebaseInitialized) {
                alert('Firebase is not configured.');
                return;
            }

            const playerName = prompt('Enter your player name (Host):');
            if (!playerName) return;

            let purseInput = prompt('Enter your starting purse amount:', '10000');
            let purseAmount = parseFloat(purseInput);
            if (isNaN(purseAmount) || purseAmount <= 0) {
                alert("Invalid amount. Defaulting to 10000.");
                purseAmount = 10000;
            }

            currentRoom = generateRoomCode();
            currentPlayerName = playerName;
            isHost = true;
            multiplayerMode = true;

            roomRef = database.ref('rooms/' + currentRoom);
            
            roomRef.set({
                host: playerName,
                players: {
                    [playerName]: {
                        name: playerName,
                        purse: purseAmount,
                        online: true,
                        joinedAt: Date.now()
                    }
                },
                gameState: {
                    started: false,
                    currentRound: 0,
                    numRounds: 5,
                    roundStatus: 'waiting'
                },
                createdAt: Date.now()
            });

            updateMultiplayerUI();
            setupRoomListeners();
            logFairness(`‚úÖ Room created: ${currentRoom}. Share this code!`);
        }

        function joinRoom() {
            if (!firebaseInitialized) {
                alert('Firebase is not configured.');
                return;
            }

            const roomCode = document.getElementById('roomCodeInput').value.trim().toUpperCase();
            if (!roomCode) {
                alert('Please enter a room code');
                return;
            }

            const playerName = prompt('Enter your player name:');
            if (!playerName) return;

            let purseInput = prompt('Enter your starting purse amount:', '10000');
            let purseAmount = parseFloat(purseInput);
            if (isNaN(purseAmount) || purseAmount <= 0) {
                 alert("Invalid amount. Defaulting to 10000.");
                 purseAmount = 10000;
            }

            currentRoom = roomCode;
            currentPlayerName = playerName;
            isHost = false;
            multiplayerMode = true;

            roomRef = database.ref('rooms/' + currentRoom);

            roomRef.once('value').then(snapshot => {
                if (!snapshot.exists()) {
                    alert('Room not found! Please check the code.');
                    leaveRoom();
                    return;
                }

                roomRef.child('players').child(playerName).set({
                    name: playerName,
                    purse: purseAmount,
                    online: true,
                    joinedAt: Date.now()
                }).catch(error => {
                    alert("Error joining: " + error.message);
                });

                updateMultiplayerUI();
                setupRoomListeners();
                logFairness(`‚úÖ Joined room: ${currentRoom}`);
            }).catch(error => {
                alert('Error accessing room: ' + error.message);
                leaveRoom();
            });
        }

        function leaveRoom() {
            if (roomRef && currentPlayerName) {
                roomRef.child('players').child(currentPlayerName).update({
                    online: false
                });
            }

            multiplayerMode = false;
            currentRoom = null;
            currentPlayerName = null;
            isHost = false;
            roomRef = null;

            updateMultiplayerUI();
            location.reload();
        }

        function updateMultiplayerUI() {
            const statusDiv = document.getElementById('multiplayerStatus');
            
            if (multiplayerMode && currentRoom) {
                statusDiv.innerHTML = `
                    <div class="room-info">
                        <div>
                            <div style="font-size: 14px; margin-bottom: 5px;">
                                ${isHost ? 'üëë Host' : 'üë§ Player'}: <strong>${currentPlayerName}</strong>
                            </div>
                            <div>Room Code: <span class="room-code">${currentRoom}</span></div>
                        </div>
                        <div>
                            <span class="online-players" id="onlineCount">üü¢ Players: ...</span>
                            <button class="btn-leave-room" onclick="leaveRoom()" style="margin-left: 10px;">Leave Room</button>
                        </div>
                    </div>
                `;
                
                // Host visibility
                const hostBtns = ['btnEndRound', 'btnNextRound'];
                hostBtns.forEach(id => {
                    const btn = document.getElementById(id);
                    if (btn) btn.style.display = isHost ? 'block' : 'none';
                });
                
            } else {
                statusDiv.innerHTML = `
                    <div class="multiplayer-controls">
                        <input type="text" id="roomCodeInput" placeholder="Enter room code to join...">
                        <button class="btn-create-room" onclick="createRoom()">Create Room</button>
                        <button class="btn-join-room" onclick="joinRoom()">Join Room</button>
                    </div>
                `;
            }
        }

        function setupRoomListeners() {
            if (!roomRef) return;

            roomRef.child('players').on('value', snapshot => {
                const playersData = snapshot.val() || {};
                const onlinePlayers = Object.values(playersData).filter(p => p.online);
                
                const countElem = document.getElementById('onlineCount');
                if (countElem) {
                    countElem.textContent = `üü¢ Players: ${onlinePlayers.length}`;
                }

                if (multiplayerMode) {
                    // Update local state list of players
                    state.players = onlinePlayers.map(p => p.name);
                    
                    // Update purses from source of truth
                    onlinePlayers.forEach(p => {
                         state.purses[p.name] = p.purse || 0;
                    });
                    
                    renderPlayers();
                    updateLeaderboard();
                }
            });

            roomRef.child('gameState').on('value', snapshot => {
                const gameState = snapshot.val();
                if (!gameState) return;

                // Sync round status
                if (gameState.currentRound > state.currentRound) {
                    syncNewRound(gameState);
                } else if (gameState.started && !state.timerRunning && gameState.timerRunning) {
                    // Timer start sync
                    state.currentItem = gameState.currentItem;
                    state.roundEndTime = gameState.roundEndTime;
                    state.timerRunning = true;
                    startTimer();
                } else if (gameState.roundStatus === 'ended' && state.roundStatus !== 'ended') {
                    // Round end sync
                    state.highestBidder = gameState.highestBidder;
                    state.highestBid = gameState.highestBid;
                    endRound(true); // Run local end round logic
                }
            });

            roomRef.child('bids').on('child_added', snapshot => {
                const bid = snapshot.val();
                if (bid && bid.player !== currentPlayerName) {
                    handleRemoteBid(bid);
                }
            });
        }

        function syncNewRound(gameState) {
            state.currentRound = gameState.currentRound;
            state.currentItem = gameState.currentItem;
            state.roundEndTime = gameState.roundEndTime;
            state.numRounds = gameState.numRounds;
            state.timerRunning = gameState.timerRunning;
            state.roundStatus = 'active';

            const [itemName, basePrice] = state.currentItem;
            state.highestBid = basePrice;
            state.highestBidder = null;
            state.lastBidder = null;
            state.perRoundPlayerBids = {};
            state.perPlayerLastBidTime = {};
            
            
            state.players.forEach(p => {
                state.perRoundPlayerBids[p] = [];
                state.perPlayerLastBidTime[p] = 0;
            });
            
            state.minIncrement = Math.max(1, basePrice * MIN_INCREMENT_RATIO);

            // Update UI
            document.getElementById('itemName').textContent = itemName;
            document.getElementById('basePrice').textContent = `‚Çπ${basePrice}`;
            document.getElementById('minIncrement').textContent = `‚Çπ${Math.floor(state.minIncrement)} (20% base)`;
            document.getElementById('highestBid').textContent = `Highest: ‚Çπ${state.highestBid} -`;
            
            addLog(`\n--- Round ${state.currentRound}/${state.numRounds}: ${itemName} (Base ‚Çπ${basePrice}) ---`, 'log-round');
            clearFairnessLog();
            updateLeaderboard();
            updatePlayerPurses();
            renderPlayers(); // Re-render to enable buttons if they were disabled
            
            if (state.timerRunning) startTimer();
        }

        function handleRemoteBid(bid) {
            state.highestBid = bid.amount;
            state.highestBidder = bid.player;
            state.lastBidder = bid.player;
            
            if(bid.remainingPurse !== undefined) {
                state.purses[bid.player] = bid.remainingPurse;
            }
            
            // Track bid for stats
            if (!state.perRoundPlayerBids[bid.player]) state.perRoundPlayerBids[bid.player] = [];
            state.perRoundPlayerBids[bid.player].push([bid.amount, bid.timestamp/1000]);

            addLog(`${bid.player} placed ‚Çπ${bid.amount.toFixed(2)}`, 'log-bid');
            document.getElementById('highestBid').textContent = `Highest: ‚Çπ${state.highestBid.toFixed(2)} - ${state.highestBidder}`;
            updateLeaderboard();
            updatePlayerPurses();
            renderPlayers();
        }

        function broadcastBid(player, amount) {
            if (!multiplayerMode || !roomRef) return;

            roomRef.child('bids').push({
                player: player,
                amount: amount,
                remainingPurse: state.purses[player],
                timestamp: Date.now()
            });
            
            
            roomRef.child('gameState').update({
                highestBid: amount,
                highestBidder: player
            });
        }

        function broadcastGameState() {
            if (!isHost || !roomRef) return;

            roomRef.child('gameState').update({
                started: true,
                currentRound: state.currentRound,
                numRounds: state.numRounds,
                currentItem: state.currentItem,
                highestBid: state.highestBid,
                highestBidder: state.highestBidder,
                roundEndTime: state.roundEndTime,
                timerRunning: state.timerRunning,
                roundStatus: state.roundStatus
            });
        }

        // ============================================
        // GAME LOGIC
        // ============================================

        function startTournament() {
            if (multiplayerMode && !isHost) {
                alert('Only the host can start the tournament!');
                return;
            }

            if (!multiplayerMode) {
                const input = document.getElementById('playersInput').value.trim();
                if (!input) { alert('Please enter players'); return; }

                const tokens = input.split(',').map(t => t.trim()).filter(t => t);
                const players = [];
                const purses = {};

                for (let tok of tokens) {
                    let name, amt;
                    if (tok.includes(':')) {
                        const parts = tok.split(':');
                        name = parts[0].trim();
                        amt = parseFloat(parts[1]);
                        if (isNaN(amt)) { alert(`Invalid purse for ${name}`); return; }
                    } else {
                        name = tok;
                        amt = 10000;
                    }
                    if (!players.includes(name)) {
                        players.push(name);
                        purses[name] = amt;
                        if (players.length >= MAX_PLAYERS) break;
                    }
                }

                if (players.length === 0) { alert('No valid players'); return; }
                state.players = players;
                state.purses = {...purses};
            }

            const rounds = parseInt(document.getElementById('roundsInput').value);
            if (isNaN(rounds) || rounds < 1) { alert('Invalid rounds'); return; }

            state.numRounds = Math.min(rounds, MAX_ROUNDS);
            state.currentRound = 0;
            state.roundResults = [];
            state.bidHistory = [];
            state.suspiciousBids = [];
            state.perRoundPlayerBids = {};
            state.perPlayerLastBidTime = {};

            updateStatus('Tournament started');
            renderPlayers();
            nextRound();
        }

        function renderPlayers() {
            const panel = document.getElementById('playersPanel');
            panel.innerHTML = '';

            state.players.forEach(player => {
                const isWithdrawn = state.withdrawnPlayers[player];
                
                // --- VISIBILITY LOGIC (CHANGE 2) ---
                // If multiplayer: Only show controls for ME.
                // If local: Show controls for everyone.
                const isMe = multiplayerMode ? (player === currentPlayerName) : true;
                const canControl = isMe; 
                
                // Badge generation
                let badges = '';
                if (player === state.highestBidder) badges += ' <span style="font-size:10px">üëë Highest</span>';
                if (state.aiPlayers[player]?.active) badges += ' <span class="ai-badge">AI</span>';
                if (isWithdrawn) badges += ' üö´';

                const div = document.createElement('div');
                div.className = 'player-item' + (isWithdrawn ? ' player-withdrawn' : '');
                
                let controlsHtml = '';

                // Only render buttons if it is the current user (or local mode)
                if (isMe) {
                    controlsHtml = `
                    <div class="player-controls">
                        <input type="number" id="bid-${player}" placeholder="Bid amount" 
                            onkeypress="if(event.key==='Enter')placeBid('${player}')" 
                            ${isWithdrawn ? 'disabled' : ''}>
                        <button class="btn-bid" onclick="placeBid('${player}')" 
                            ${isWithdrawn ? 'disabled' : ''}>Bid</button>
                        <button class="btn-ai-toggle" onclick="openAIConfig('${player}')"
                            >AI</button>
                    </div>
                    <div class="quick-bid-buttons">
                        <button class="btn-quick-min" onclick="quickBid('${player}', 'min')" 
                            ${isWithdrawn ? 'disabled' : ''}>+Min</button>
                        <button class="btn-quick-10" onclick="quickBid('${player}', '10')" 
                            ${isWithdrawn ? 'disabled' : ''}>+10%</button>
                        <button class="btn-quick-25" onclick="quickBid('${player}', '25')" 
                            ${isWithdrawn ? 'disabled' : ''}>+25%</button>
                        <button class="btn-quick-max" onclick="quickBid('${player}', 'max')" 
                            ${isWithdrawn ? 'disabled' : ''}>Max</button>
                        <button class="btn-withdraw" onclick="toggleWithdraw('${player}')">
                            ${isWithdrawn ? 'Rejoin' : 'Withdraw'}
                        </button>
                    </div>
                    `;
                } else {
                    // For other players, just show a placeholder or status
                    controlsHtml = `<div style="font-size: 11px; color: #888; margin-top:5px;"><i>Controls hidden (Opponent)</i></div>`;
                }

                div.innerHTML = `
                    <div class="player-header">
                        <span class="player-name">${player} ${badges}</span>
                        <span class="player-purse" id="purse-${player}">‚Çπ${Math.floor(state.purses[player])}</span>
                    </div>
                    ${controlsHtml}
                `;
                panel.appendChild(div);
            });
        }

        function quickBid(player, type) {
            if (!state.currentItem || !state.timerRunning) {
                alert('No active round');
                return;
            }

            const [itemName, basePrice] = state.currentItem;
            const purse = state.purses[player] || 0;
            let amount;

            switch(type) {
                case 'min':
                    amount = state.highestBid + state.minIncrement;
                    break;
                case '10':
                    amount = state.highestBid + (basePrice * 0.10);
                    break;
                case '25':
                    amount = state.highestBid + (basePrice * 0.25);
                    break;
                case 'max':
                    amount = purse;
                    break;
            }

            if (state.highestBidder !== null && amount < state.highestBid + state.minIncrement) {
                amount = state.highestBid + state.minIncrement;
            }

            placeBid(player, amount, true);
        }

        function toggleWithdraw(player) {
            if (state.withdrawnPlayers[player]) {
                delete state.withdrawnPlayers[player];
                logFairness(`${player} rejoined the round`);
            } else {
                state.withdrawnPlayers[player] = true;
                logFairness(`${player} withdrew from this round`);
            }
            renderPlayers();
        }

        function nextRound() {
            if (multiplayerMode && !isHost) return;

            if (state.currentRound >= state.numRounds) {
                showFinalResults();
                return;
            }

            state.currentRound++;
            state.currentItem = ITEMS[(state.currentRound - 1) % ITEMS.length];
            const [itemName, basePrice] = state.currentItem;
            
            state.highestBid = basePrice;
            state.highestBidder = null;
            state.lastBidder = null;
            state.perRoundPlayerBids = {};
            state.perPlayerLastBidTime = {};
            state.players.forEach(p => {
                state.perRoundPlayerBids[p] = [];
                state.perPlayerLastBidTime[p] = 0;
            });
            
            state.roundEndTime = Date.now() + (ROUND_DURATION * 1000);
            state.timerRunning = true;
            state.roundStatus = 'active';
            state.minIncrement = Math.max(1, basePrice * MIN_INCREMENT_RATIO);

            // AI Logic
            Object.keys(state.aiPlayers).forEach(player => {
                if (state.aiPlayers[player].active) {
                    clearTimeout(state.aiTimers[player]);
                    state.aiTimers[player] = setTimeout(() => aiMakeBid(player), 800);
                }
            });

            // UI Updates
            document.getElementById('itemName').textContent = itemName;
            document.getElementById('basePrice').textContent = `‚Çπ${basePrice}`;
            document.getElementById('minIncrement').textContent = `‚Çπ${Math.floor(state.minIncrement)} (20% base)`;
            document.getElementById('highestBid').textContent = `Highest: ‚Çπ${state.highestBid} -`;
            
            addLog(`\n--- Round ${state.currentRound}/${state.numRounds}: ${itemName} (Base ‚Çπ${basePrice}) ---`, 'log-round');
            clearFairnessLog();
            updateLeaderboard();
            updatePlayerPurses();
            renderPlayers(); // Reset visual state
            startTimer();

            // Sync
            if (multiplayerMode) {
                broadcastGameState();
            }
        }

        function startTimer() {
            if (state.timerInterval) clearInterval(state.timerInterval);
            
            state.timerInterval = setInterval(() => {
                if (!state.timerRunning) {
                    clearInterval(state.timerInterval);
                    return;
                }

                const now = Date.now();
                const diff = Math.ceil((state.roundEndTime - now) / 1000);
                state.roundTimeLeft = diff;

                if (diff < 0) state.roundTimeLeft = 0;

                const mins = Math.floor(state.roundTimeLeft / 60);
                const secs = state.roundTimeLeft % 60;
                document.getElementById('timer').textContent = `‚è≥ ${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;

                if (state.roundTimeLeft <= 0) {
                    state.timerRunning = false;
                    clearInterval(state.timerInterval);
                    if (!multiplayerMode || isHost) {
                        endRound(false); // End logic triggered by host or local
                    }
                    return;
                }
            }, 1000);
        }

        function placeBid(player, amount = null, notify = true) {
            if (!state.timerRunning) {
                if (notify) alert('Round finished ‚Äì no bids accepted.');
                return;
            }

            if (state.withdrawnPlayers[player]) {
                if (notify) alert(`${player} has withdrawn from this round.`);
                return;
            }

            const now = Date.now() / 1000;
            const [itemName, basePrice] = state.currentItem;

            if (amount === null) {
                const input = document.getElementById(`bid-${player}`);
                if (!input) return; // Guard for hidden controls
                amount = parseFloat(input.value);
                input.value = '';
                if (isNaN(amount)) {
                    alert('Enter a valid amount');
                    return;
                }
            }

            if (state.lastBidder === player) {
                logFairness(`${player} attempted consecutive bid ‚Äì rejected.`);
                if (notify) alert(`${player}, you cannot bid consecutively.`);
                return;
            }

            const lastTime = state.perPlayerLastBidTime[player] || 0;
            if (now - lastTime < ANTI_SPAM_SECONDS) {
                logFairness(`${player} bidding too quickly (spam).`);
                if (notify) alert(`${player}, wait at least ${ANTI_SPAM_SECONDS}s between bids.`);
                return;
            }

            const purse = state.purses[player] || 0;
            if (amount > purse) {
                logFairness(`${player} tried to bid ‚Çπ${amount.toFixed(2)} but only has ‚Çπ${purse.toFixed(2)}`);
                if (notify) alert(`${player}, you have only ‚Çπ${purse.toFixed(2)} left in your purse.`);
                return;
            }

            if (amount < basePrice) {
                logFairness(`${player} bid below base price: ‚Çπ${amount.toFixed(2)}`);
                if (notify) alert(`Minimum base price is ‚Çπ${basePrice}.`);
                return;
            }

            if (state.highestBidder !== null) {
                const requiredMin = state.highestBid + state.minIncrement;
                if (amount < requiredMin) {
                    logFairness(`${player} bid below min increment (requires >= ‚Çπ${requiredMin.toFixed(2)}).`);
                    if (notify) alert(`Next bid must be at least ‚Çπ${Math.floor(requiredMin)} (current highest + min increment).`);
                    return;
                }
            }

            if (state.highestBid > 0 && amount > UNUSUAL_MULTIPLIER * state.highestBid) {
                state.suspiciousBids.push([state.currentRound, player, amount, now]);
                logFairness(`Unusual jump by ${player}: ‚Çπ${amount.toFixed(2)} (> ${UNUSUAL_MULTIPLIER}x).`);
                if (notify) alert(`${player}, this jump looks unusual ‚Äì flagged.`);
            }

            state.highestBid = amount;
            state.highestBidder = player;
            state.lastBidder = player;
            if(!state.perRoundPlayerBids[player]) state.perRoundPlayerBids[player] = [];
            state.perRoundPlayerBids[player].push([amount, now]);
            state.perPlayerLastBidTime[player] = now;
            state.bidHistory.push([state.currentRound, player, amount, now]);

            if (state.roundTimeLeft <= ANTI_SNIPING_WINDOW) {
                state.roundEndTime += (ANTI_SNIPING_EXTENSION * 1000);
                logFairness(`Anti-sniping: extended by ${ANTI_SNIPING_EXTENSION}s due to last-second bid by ${player}.`);
            }

            addLog(`${player} placed ‚Çπ${amount.toFixed(2)}`, 'log-bid');
            document.getElementById('highestBid').textContent = `Highest: ‚Çπ${state.highestBid.toFixed(2)} - ${state.highestBidder}`;
            updateLeaderboard();
            updatePlayerPurses();
            renderPlayers(); // Updates badges
            updateStrategyPredictions();
            
            if (multiplayerMode) {
                broadcastBid(player, amount);
            }
        }

        // --- CHANGE 3: SYNC UPDATES & ROUND END LOGIC ---
        function endRound(isSyncEvent = false) {
            // Only Host or Local Singleplayer can trigger logic.
            // But if isSyncEvent is true, it means we received a 'round ended' signal from server
            if (multiplayerMode && !isHost && !isSyncEvent) return;
            
            if (state.roundStatus === 'ended') return; // Already ended

            state.timerRunning = false;
            clearInterval(state.timerInterval);
            state.roundStatus = 'ended';

            const [itemName, basePrice] = state.currentItem;
            
            if (state.highestBidder) {
                const winner = state.highestBidder;
                const amount = state.highestBid;
                
                // Deduct purse locally if host, or rely on sync
                if (!multiplayerMode || isHost) {
                    state.purses[winner] = Math.max(0, state.purses[winner] - amount);
                    if (multiplayerMode && roomRef) {
                        roomRef.child('players').child(winner).update({ purse: state.purses[winner] });
                    }
                }
                
                // Avoid duplicates in results
                const alreadyRecorded = state.roundResults.some(r => r[0] === state.currentRound);
                if (!alreadyRecorded) {
                    state.roundResults.push([state.currentRound, itemName, winner, amount]);
                }
                
                addLog(`--- ROUND RESULT: ${winner} wins ${itemName} at ‚Çπ${amount.toFixed(2)} ---`, 'log-result');
            } else {
                addLog(`--- ROUND RESULT: No bids for ${itemName} ---`, 'log-result');
            }

            performRoundFairnessAnalysis(); // Updates suggestions
            updateLeaderboard();
            updatePlayerPurses();
            renderPlayers();
            updateStatus(`Round ${state.currentRound}/${state.numRounds} ended`);
            
            // --- CHANGE 1: FORCE SUGGESTIONS FOR LOSERS ---
            updateSuggestions(); 
            
            if (multiplayerMode && isHost && !isSyncEvent) {
                broadcastGameState();
            }
        }

        function performRoundFairnessAnalysis() {
            const totalBids = Object.values(state.perRoundPlayerBids).reduce((sum, arr) => sum + arr.length, 0);
            if (totalBids === 0) {
                logFairness('No bids this round.');
                return;
            }

            Object.entries(state.perRoundPlayerBids).forEach(([player, bids]) => {
                if (bids.length > 0.6 * totalBids) {
                    logFairness(`${player} dominated this round with ${bids.length}/${totalBids} bids.`);
                }
            });

            updateStrategyPredictions();
        }

        function predictStrategy(bidRecords, basePrice, roundEndTime) {
            if (!bidRecords || bidRecords.length === 0) {
                return { strategy: "Passive", explanation: "No bids" };
            }

            const amounts = bidRecords.map(r => r[0]);
            const times = bidRecords.map(r => r[1]);
            const n = amounts.length;

            const increments = [];
            for (let i = 1; i < n; i++) {
                if (amounts[i] - amounts[i-1] > 0) {
                    increments.push(amounts[i] - amounts[i-1]);
                }
            }
            const avgInc = increments.length > 0 ? increments.reduce((a, b) => a + b, 0) / increments.length : 0;

            let avgTimeBetween = Infinity;
            if (n >= 2) {
                const diffs = [];
                for (let i = 1; i < n; i++) {
                    diffs.push(times[i] - times[i-1]);
                }
                avgTimeBetween = diffs.reduce((a, b) => a + b, 0) / diffs.length;
            }

            const secondsBeforeEnd = Math.max(0, (roundEndTime - Date.now())/1000);

            if (secondsBeforeEnd <= ANTI_SNIPING_WINDOW && n <= 3) {
                return { strategy: "Sniper", explanation: `last bid ${Math.floor(secondsBeforeEnd)}s before end` };
            }
            if (avgInc > 0 && avgInc <= Math.max(100, basePrice * 0.02) && n >= 2) {
                return { strategy: "Incremental", explanation: `avg inc ‚Çπ${avgInc.toFixed(0)}` };
            }
            if (avgInc >= Math.max(500, basePrice * 0.15)) {
                return { strategy: "Aggressive", explanation: `avg inc ‚Çπ${avgInc.toFixed(0)}` };
            }
            if (avgTimeBetween < 3 && n >= 3) {
                return { strategy: "Rapid", explanation: `avg ${avgTimeBetween.toFixed(1)}s between bids` };
            }
            if (n === 1) {
                if (amounts[0] >= basePrice * 1.5) {
                    return { strategy: "Surprise", explanation: "single high bid" };
                }
                return { strategy: "Passive", explanation: "single bid" };
            }
            return { strategy: "Mixed", explanation: `${n} bids, avg inc ‚Çπ${avgInc.toFixed(0)}` };
        }

        function updateStrategyPredictions() {
            const panel = document.getElementById('strategyPanel');
            panel.innerHTML = '';
            const basePrice = state.currentItem ? state.currentItem[1] : 0;

            state.players.forEach(player => {
                // if (state.aiPlayers[player]?.active) return; // Optional: Show AI strategy too
                const bidRecords = state.bidHistory.filter(b => b[1] === player).map(b => [b[2], b[3]]);
                if (bidRecords.length === 0) return;
                const prediction = predictStrategy(bidRecords, basePrice, state.roundEndTime);
                const item = document.createElement('div');
                item.className = 'strategy-item';
                item.innerHTML = `<div class="player-strategy">${player}</div><div>Strategy: <span class="strategy-type">${prediction.strategy}</span></div><div class="strategy-desc">${prediction.explanation}</div>`;
                panel.appendChild(item);
            });
        }

        // --- CHANGE 1: REVISED SUGGESTION LOGIC ---
        function updateSuggestions() {
            const panel = document.getElementById('suggestionsPanel');
            panel.innerHTML = '';
            const winner = state.highestBidder;
            const basePrice = state.currentItem ? state.currentItem[1] : 0;
            
            // Loop through ALL players
            state.players.forEach(player => {
                
                if (player === winner) return;

                const roundBids = state.perRoundPlayerBids[player] || [];
                
                // Logic to generate specific advice
                let prediction = { strategy: "Did Not Bid", explanation: "" };
                if (roundBids.length > 0) {
                     prediction = predictStrategy(roundBids, basePrice, state.roundEndTime);
                }
                
                let suggestion = "";
                
                if (roundBids.length === 0) {
                     suggestion = "‚ö†Ô∏è You didn't place any bids. You can't win if you don't play! Try a minimum bid early on.";
                } else {
                    switch (prediction.strategy) {
                        case "Passive": suggestion = "üí° You were too passive. Try bidding more frequently with small increments to stay competitive."; break;
                        case "Incremental": suggestion = "üí° You bid steadily but lost. Consider timing a larger bid strategically or waiting until the very end."; break;
                        case "Aggressive": suggestion = "üí° You bid aggressively but still lost. You might be spending too much too fast. Pace yourself."; break;
                        case "Sniper": suggestion = "üí° Good sniping attempt, but you were outbid. Ensure you can afford a rapid counter-bid if an anti-snipe extension triggers."; break;
                        case "Rapid": suggestion = "üí° You bid very fast. This shows commitment but drains energy. Try fewer, stronger bids."; break;
                        case "Surprise": suggestion = "üí° Your single big bid didn't hold up. Follow up with sustained pressure next time."; break;
                        default: suggestion = "üí° Mix your strategy: combine incremental bids with well-timed jumps.";
                    }
                }
                
                const item = document.createElement('div');
                item.className = 'suggestion-item';
                item.innerHTML = `<div class="player-name-sug">${player} (Did not win)</div><div class="suggestion-text">${suggestion}</div>`;
                panel.appendChild(item);
            });

            if (panel.children.length === 0) {
                if (!winner) panel.innerHTML = '<div style="color: #999; font-style: italic;">No winner this round.</div>';
                else panel.innerHTML = '<div style="color: #999; font-style: italic;">Waiting for round end...</div>';
            }
        }

        // ============================================
        // AI & UTIL FUNCTIONS
        // ============================================

        function aiMakeBid(player) {
            const ai = state.aiPlayers[player];
            if (!ai || !ai.active) return;

            if (!state.timerRunning || !state.currentItem) {
                state.aiTimers[player] = setTimeout(() => aiMakeBid(player), 1000);
                return;
            }

            if (state.withdrawnPlayers[player]) return;

            const strategy = ai.strategy;
            const purse = state.purses[player] || 0;
            const [itemName, basePrice] = state.currentItem;
            const cur = state.highestBid;

            const thinkingChance = Math.random();
            if (thinkingChance < 0.15) {
                const thinkTime = 1000 + Math.random() * 3000;
                state.aiTimers[player] = setTimeout(() => aiMakeBid(player), thinkTime);
                return;
            }

            let bid;
            const rand = (min, max) => min + Math.random() * (max - min);

            if (strategy === 'Aggressive') {
                const jump = basePrice * rand(0.25, 0.40);
                bid = Math.max(cur + jump, cur + state.minIncrement);
            } else if (strategy === 'Conservative') {
                const jump = basePrice * rand(0.05, 0.12);
                bid = cur + Math.max(jump, state.minIncrement);
            } else if (strategy === 'Passive') {
                if (Math.random() < 0.6) {
                    state.aiTimers[player] = setTimeout(() => aiMakeBid(player), rand(3000, 8000));
                    return;
                }
                bid = cur + state.minIncrement;
            } else if (strategy === 'Sniper') {
                if (state.roundTimeLeft > (ANTI_SNIPING_WINDOW + 1)) {
                    const delay = Math.max(1000, (state.roundTimeLeft - (ANTI_SNIPING_WINDOW + 1)) * 1000);
                    const variance = rand(-2000, 2000);
                    state.aiTimers[player] = setTimeout(() => aiMakeBid(player), delay + variance);
                    return;
                }
                bid = cur + Math.max(state.minIncrement, basePrice * rand(0.05, 0.2));
            } else if (strategy === 'Adaptive') {
                if (purse > basePrice * 2) {
                    bid = cur + Math.max(state.minIncrement, basePrice * rand(0.12, 0.3));
                } else {
                    bid = cur + state.minIncrement;
                }
            } else if (strategy === 'Rapid') {
                bid = cur + Math.max(state.minIncrement, basePrice * rand(0.03, 0.08));
            } else {
                bid = cur + Math.max(state.minIncrement, basePrice * rand(0.05, 0.12));
            }

            if (bid > purse) {
                if (purse > cur) {
                    bid = purse;
                } else {
                    state.aiTimers[player] = setTimeout(() => aiMakeBid(player), 2000);
                    return;
                }
            }

            placeBid(player, bid, false);

            let wait;
            if (strategy === 'Aggressive') wait = rand(800, 2500);
            else if (strategy === 'Rapid') wait = rand(600, 1500);
            else if (strategy === 'Sniper') wait = rand(500, 2000);
            else wait = rand(1500, 5000);

            if (Math.random() < 0.1) wait += rand(2000, 5000);
            state.aiTimers[player] = setTimeout(() => aiMakeBid(player), wait);
        }

        function openAIConfig(player) {
            state.currentAIPlayer = player;
            document.getElementById('aiModalTitle').textContent = `Configure AI for ${player}`;
            const ai = state.aiPlayers[player];
            if (ai) {
                document.getElementById('aiStrategy').value = ai.strategy;
                document.getElementById('aiActive').checked = ai.active;
            } else {
                document.getElementById('aiStrategy').value = 'Incremental';
                document.getElementById('aiActive').checked = false;
            }
            document.getElementById('aiModal').classList.add('active');
        }

        function applyAIConfig() {
            const player = state.currentAIPlayer;
            const strategy = document.getElementById('aiStrategy').value;
            const active = document.getElementById('aiActive').checked;
            if (active) activateAIForPlayer(player, strategy);
            else stopAIForPlayer(player);
            closeAIModal();
            renderPlayers();
        }

        function closeAIModal() {
            document.getElementById('aiModal').classList.remove('active');
            state.currentAIPlayer = null;
        }

        function activateAIForPlayer(player, strategy) {
            state.aiPlayers[player] = { strategy, active: true };
            clearTimeout(state.aiTimers[player]);
            state.aiTimers[player] = setTimeout(() => aiMakeBid(player), 1000);
            logFairness(`‚úÖ AI activated for ${player} (${strategy})`);
        }

        function stopAIForPlayer(player) {
            if (state.aiPlayers[player]) state.aiPlayers[player].active = false;
            clearTimeout(state.aiTimers[player]);
            delete state.aiTimers[player];
            delete state.aiPlayers[player];
            logFairness(`‚ùå AI deactivated for ${player}`);
        }

        function showAddAIModal() {
            const aiCount = state.players.filter(p => p.startsWith('AI_Bot')).length;
            document.getElementById('newAIName').value = `AI_Bot${aiCount + 1}`;
            document.getElementById('newAIPurse').value = '10000';
            document.getElementById('newAIStrategy').value = 'Incremental';
            document.getElementById('newAIActive').checked = true;
            document.getElementById('addAIModal').classList.add('active');
        }

        function closeAddAIModal() {
            document.getElementById('addAIModal').classList.remove('active');
        }

        function createAIBot() {
            const name = document.getElementById('newAIName').value.trim();
            const purse = parseFloat(document.getElementById('newAIPurse').value);
            const strategy = document.getElementById('newAIStrategy').value;
            const active = document.getElementById('newAIActive').checked;

            if (!name) { alert('AI name required'); return; }
            if (isNaN(purse)) { alert('Invalid purse'); return; }
            if (state.players.includes(name)) { alert(`Player '${name}' already exists`); return; }
            if (state.players.length >= MAX_PLAYERS) { alert(`Max ${MAX_PLAYERS} players reached`); return; }

            state.players.push(name);
            state.purses[name] = purse;
            
            if (state.timerRunning || state.currentRound > 0) {
                state.perRoundPlayerBids[name] = [];
                state.perPlayerLastBidTime[name] = 0;
            }

            if (active) activateAIForPlayer(name, strategy);

            logFairness(`‚úÖ Added AI Bot '${name}' (${strategy}) with purse ‚Çπ${purse.toFixed(0)}`);
            renderPlayers();
            updateLeaderboard();
            closeAddAIModal();
        }

        function updateLeaderboard() {
            const tbody = document.getElementById('leaderboardBody');
            tbody.innerHTML = '';
            state.players.forEach(player => {
                const wins = state.roundResults.filter(r => r[2] === player).length;
                const spent = state.roundResults.filter(r => r[2] === player).reduce((sum, r) => sum + r[3], 0);
                const bidsCount = state.bidHistory.filter(b => b[1] === player).length;
                const row = document.createElement('tr');
                row.innerHTML = `<td>${player}${state.aiPlayers[player]?.active ? '<span class="ai-badge">AI</span>' : ''}</td><td>${wins}</td><td>‚Çπ${Math.floor(spent)}</td><td>${bidsCount}</td><td>‚Çπ${Math.floor(state.purses[player] || 0)}</td>`;
                tbody.appendChild(row);
            });
        }

        function updatePlayerPurses() {
            state.players.forEach(player => {
                const elem = document.getElementById(`purse-${player}`);
                if (elem) elem.textContent = `‚Çπ${Math.floor(state.purses[player] || 0)}`;
            });
        }

        function addLog(message, className = 'log-entry') {
            const log = document.getElementById('auctionLog');
            const div = document.createElement('div');
            div.className = className;
            div.textContent = message;
            log.appendChild(div);
            log.scrollTop = log.scrollHeight;
        }

        function logFairness(message) {
            const log = document.getElementById('fairnessLog');
            const time = new Date().toLocaleTimeString();
            const div = document.createElement('div');
            div.textContent = `[${time}] ${message}`;
            log.appendChild(div);
            log.scrollTop = log.scrollHeight;
        }

        function clearFairnessLog() { document.getElementById('fairnessLog').innerHTML = ''; }
        function updateStatus(message) { document.getElementById('statusBar').textContent = message; }

        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            const btn = document.querySelector('.dark-mode-toggle');
            if (document.body.classList.contains('dark-mode')) {
                btn.textContent = '‚òÄÔ∏è Light Mode';
                localStorage.setItem('darkMode', 'enabled');
            } else {
                btn.textContent = 'üåô Dark Mode';
                localStorage.setItem('darkMode', 'disabled');
            }
        }

        window.addEventListener('DOMContentLoaded', () => {
            if (localStorage.getItem('darkMode') === 'enabled') {
                document.body.classList.add('dark-mode');
                document.querySelector('.dark-mode-toggle').textContent = '‚òÄÔ∏è Light Mode';
            }
        });

        function showFinalResults() {
            let message = 'Final Results:\n\n';
            state.roundResults.forEach(([round, item, winner, amount]) => {
                message += `Round ${round}: ${item} - ${winner} at ‚Çπ${amount.toFixed(2)}\n`;
            });
            if (state.suspiciousBids.length > 0) {
                message += '\n\nSuspicious bids:\n';
                state.suspiciousBids.forEach(([round, name, amount, ts]) => {
                    const time = new Date(ts * 1000).toLocaleTimeString();
                    message += `Round ${round}: ${name} ‚Üí ‚Çπ${amount.toFixed(2)} at ${time}\n`;
                });
            }
            message += '\n\nPlayer Summary:\n';
            state.players.forEach(player => {
                const wins = state.roundResults.filter(r => r[2] === player).length;
                const spent = state.roundResults.filter(r => r[2] === player).reduce((sum, r) => sum + r[3], 0);
                message += `${player}: ${wins} wins, ‚Çπ${Math.floor(spent)} spent, ‚Çπ${Math.floor(state.purses[player])} remaining\n`;
            });
            alert(message);
            addLog('\n=== Tournament Summary ===', 'log-result');
            addLog(message);
        }
    </script>
</body>
</html>